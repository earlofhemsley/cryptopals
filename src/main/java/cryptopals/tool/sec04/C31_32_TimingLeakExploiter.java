package cryptopals.tool.sec04;

import lombok.RequiredArgsConstructor;
import lombok.SneakyThrows;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.tuple.Pair;
import org.bouncycastle.util.Arrays;
import org.bouncycastle.util.encoders.Hex;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.client.RestTemplate;

import java.net.URI;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;
import java.util.stream.Collectors;

/**
 * a class dedicated to exploiting timing leaks in order to complete
 * challenges 31 and 32
 */
@Slf4j
@RequiredArgsConstructor
public class C31_32_TimingLeakExploiter {

    private final String file;
    private final int port;
    private final RestTemplate restTemplate;
    private final Executor ex = Executors.newFixedThreadPool(5);

    @SneakyThrows
    public void exploitLeak(final byte[] forgedHash, final long startingThreshold, final long thresholdIncrement) {
        //define a threshold. if a request takes longer than this, count it as valid
        long threshold = startingThreshold;
        long responseTime;

        //prime the pump
        makeRequest(forgedHash, startingThreshold).get();

        for (int i = 0; i < forgedHash.length; i++) {
            final var futuresMap = new HashMap<Byte, List<CompletableFuture<Pair<HttpStatus, Long>>>>();
            final var timingMap = new HashMap<Byte, Double>();
            for (int k = Byte.MIN_VALUE; k <= Byte.MAX_VALUE; k++) {
                final List<byte[]> samples = new ArrayList<>();
                for (int j = 0; j < 33; j++) {
                    var clone = Arrays.clone(forgedHash);
                    clone[i] = (byte) k;
                    samples.add(clone);
                }
                final long finalThreshold = threshold;
                final var futures = samples.parallelStream().map(s -> makeRequest(s, finalThreshold)).collect(Collectors.toList());
                futuresMap.put((byte) k, futures);
            }

            byte winner = Byte.MIN_VALUE;
            double maxTiming = Double.MIN_VALUE;

            for (Map.Entry<Byte, List<CompletableFuture<Pair<HttpStatus, Long>>>> entry : futuresMap.entrySet()) {
                var futures = entry.getValue();
                var byteResult = CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]));
                var contentResult = byteResult.thenApply(f -> futures.stream().map(CompletableFuture::join).collect(Collectors.toList()));
                final List<Pair<HttpStatus, Long>> timingList = contentResult.get();
                final long total = timingList.stream().map(Pair::getRight).reduce(0L, Long::sum);
                final double mean = (double) total / (double) timingList.size();
                timingMap.put(entry.getKey(), mean);
            }

            final var longest = timingMap.entrySet().stream().max(Map.Entry.comparingByValue()).get();

            forgedHash[i] = longest.getKey();
            log.info("found a byte. now the hash is {}", Hex.toHexString(forgedHash));

            if (HttpStatus.OK == makeRequest(forgedHash, 0L).get().getKey()) {
                log.info("the hash was {}", Hex.toHexString(forgedHash));
                break;
            } else {
                //add fifty to the threshold
                threshold += thresholdIncrement;
            }
        }
    }

    public CompletableFuture<Pair<HttpStatus, Long>> makeRequest(final byte[] forgedHash, final long threshold) {
        return CompletableFuture.supplyAsync(() -> {
            final long startTime = System.currentTimeMillis();
            final String signature = Hex.toHexString(forgedHash);
            final URI uri = URI.create(String.format("http://localhost:%s/leak/test/%s?signature=%s",
                    port,
                    file,
                    signature
            ));
            final ResponseEntity<String> response = restTemplate.getForEntity(uri, String.class);
            final long responseTime = System.currentTimeMillis() - startTime;
            if (responseTime > threshold) {
                log.info("{} response time: {}", Hex.toHexString(forgedHash), responseTime);
            }
            if (response.getStatusCode() == HttpStatus.BAD_REQUEST) {
                throw new AssertionError("Got a bad request response");
            }
            return Pair.of(response.getStatusCode(), responseTime);
        }, ex);
    }
}
