package cryptopals.tool.sec04;

import cryptopals.exceptions.CryptopalsException;
import lombok.RequiredArgsConstructor;
import lombok.SneakyThrows;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.tuple.Pair;
import org.bouncycastle.util.Arrays;
import org.bouncycastle.util.encoders.Hex;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.client.RestTemplate;

import java.net.URI;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;
import java.util.stream.Collectors;
import java.util.stream.LongStream;

/**
 * a class dedicated to exploiting timing leaks in order to complete
 * challenges 31 and 32
 */
@Slf4j
public class C31_32_TimingLeakExploiter {

    private final String file;
    private final int port;
    private final RestTemplate restTemplate;
    private final Executor ex;

    public C31_32_TimingLeakExploiter(String file, int port, RestTemplate restTemplate, int numOfThreads) {
        this.file = file;
        this.port = port;
        this.restTemplate = restTemplate;
        this.ex = Executors.newFixedThreadPool(numOfThreads);
    }

    @SneakyThrows
    public void exploitLeak(final byte[] forgedHash) {
        for (int i = 0; i < forgedHash.length; i++) {
            final var futuresMap = new HashMap<Byte, List<CompletableFuture<Pair<HttpStatus, Long>>>>();
            for (int k = Byte.MIN_VALUE; k <= Byte.MAX_VALUE; k++) {
                final List<byte[]> samples = new ArrayList<>();
                for (int j = 0; j < 33; j++) {
                    var clone = Arrays.clone(forgedHash);
                    clone[i] = (byte) k;
                    samples.add(clone);
                }
                final var futures = samples.parallelStream().map(this::makeRequest).collect(Collectors.toList());
                futuresMap.put((byte) k, futures);
            }

            byte winner = Byte.MIN_VALUE;
            double maxTiming = Double.MIN_VALUE;

            for (Map.Entry<Byte, List<CompletableFuture<Pair<HttpStatus, Long>>>> entry : futuresMap.entrySet()) {
                var futures = entry.getValue();
                var all = CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]));
                var totalTime = all.thenApply(v -> futures.stream().map(CompletableFuture::join).map(Pair::getRight).reduce(0L, Long::sum)).get();
                final double mean = totalTime.doubleValue() / (double) entry.getValue().size();
                if (mean > maxTiming) {
                    winner = entry.getKey();
                    maxTiming = mean;
                    log.info("new max timing --> {}: {}ms", Hex.toHexString(new byte[] {winner}), maxTiming);
                }
            }

            forgedHash[i] = winner;
            log.info("found a byte. now the hash is {}", Hex.toHexString(forgedHash));

            if (HttpStatus.OK == makeRequest(forgedHash).get().getKey()) {
                log.info("the hash was {}", Hex.toHexString(forgedHash));
                break;
            }
        }
    }

    public CompletableFuture<Pair<HttpStatus, Long>> makeRequest(final byte[] forgedHash) {
        return CompletableFuture.supplyAsync(() -> {
            final long startTime = System.currentTimeMillis();
            final String signature = Hex.toHexString(forgedHash);
            final URI uri = URI.create(String.format("http://localhost:%s/leak/test/%s?signature=%s",
                    port,
                    file,
                    signature
            ));
            final ResponseEntity<String> response = restTemplate.getForEntity(uri, String.class);
            final long responseTime = System.currentTimeMillis() - startTime;
            if (response.getStatusCode() == HttpStatus.BAD_REQUEST) {
                throw new AssertionError("Got a bad request response");
            }
            return Pair.of(response.getStatusCode(), responseTime);
        }, ex);
    }
}
